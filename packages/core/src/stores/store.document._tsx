import { Store } from 'stores';
import { action, observable, runInAction } from 'mobx';
import { injectable } from 'inversify';
import { app, lazyInject } from 'ioc';
import { Api, api } from '@codex/api';
import { get, has, set, snakeCase } from 'lodash';

@injectable()
export class DocumentStore {
    @lazyInject('api') api: Api;

    constructor(protected store: Store) {
        app.bind(DocumentStore).toConstantValue(this);
    }

    @observable fetching: boolean      = false;
    // @observable key: string            = null;
    // @observable content: string        = null;
    @observable project: api.Project   = null;
    @observable revision: api.Revision = null;
    @observable document: api.Document = null;

    @action mergeLayout(mergable: { layout?: Partial<api.Layout> }) {
        if ( mergable.layout ) {
            this.store.layout.merge(mergable.layout);
        }
    }

    @action setDocument(document: api.Document | null) {
        this.document = document;
        this.mergeLayout(document);
        if ( document ) {
            // this.key     = document.key;
            // this.content = document.content;
        }
    }

    @action setProject(project: api.Project | null) {
        this.project = project;
        this.mergeLayout(project);
    }

    @action setRevision(revision: api.Revision | null) {
        this.revision = revision;
        this.mergeLayout(revision);
    }

    async fetchDocument(project: string, revision: string, document: string) {
        runInAction(() => {
            this.fetching = true;
            // this.content  = null;
        });
        await this.fetch(project, revision, document);
        runInAction(() => {
            this.fetching = false;
        });
    }

    fetched: any = {};

    protected async fetch(projectKey: string, revisionKey: string, documentKey: string) {
        let query        = [];
        let projectPath  = `projects.${snakeCase(projectKey)}`;
        let revisionPath = `revisions.${snakeCase(projectKey)}.${snakeCase(revisionKey)}`;
        let documentPath = `documents.${snakeCase(projectKey)}.${snakeCase(revisionKey)}.${snakeCase(documentKey)}`;
        let hasProject   = has(this.fetched, projectPath);
        let hasRevision  = has(this.fetched, revisionPath);
        let hasDocument  = has(this.fetched, documentPath);

        if ( ! hasProject ) {
            query.push(`
project(key: $projectKey){
    key
    changes
}`);
        }
        if ( ! hasRevision ) {
            query.push(`
revision(projectKey: $projectKey, revisionKey: $revisionKey){
    key
    changes
}`);
        }
        if ( ! hasDocument ) {
            query.push(`
document(projectKey: $projectKey, revisionKey: $revisionKey, documentKey: $documentKey){
    key
    changes
    content
}`);
        }

        if ( query.length > 0 ) {
            let result = await this.api.query(`
query Fetch($projectKey: ID!, $revisionKey: ID!, $documentKey: ID!) {
    ${query.join('\n')}
}        
        `, { projectKey, revisionKey, documentKey });

            if ( ! hasProject ) {
                set(this.fetched, projectPath, result.project.changes);
                set(this.fetched, projectPath + '.key', result.project.key);
            }
            if ( ! hasRevision ) {
                set(this.fetched, revisionPath, result.revision.changes);
                set(this.fetched, revisionPath + '.key', result.revision.key);
            }
            if ( ! hasDocument ) {
                set(this.fetched, documentPath, result.document.changes);
                set(this.fetched, documentPath + '.key', result.document.key);
                set(this.fetched, documentPath + '.content', result.document.content);
            }
        }

        runInAction(() => {
            if ( ! this.project || this.project.key !== projectKey ) {
                this.setProject(get(this.fetched, projectPath));
                this.revision = null;
                this.document = null;
            }
            if ( ! this.revision || this.revision.key !== revisionKey ) {
                this.setRevision(get(this.fetched, revisionPath));
                this.document = null;
            }
            if ( ! this.document || this.document.key !== documentKey ) {
                this.setDocument(get(this.fetched, documentPath));
            }
        });

    }
}
